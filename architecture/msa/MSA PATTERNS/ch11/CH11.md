# 프로덕션 레디 서비스 개발

* 서비스를 프로덕션에 배포할 수 있게 준비하려면 보안, 구성성, 관측성 보장 필요
* 구성성 : 외부 서비스에 대한 구성 프로퍼티값을 서비스에 공급하는 외부화 구성 메커니즘 활용 필요
* 관측성 : 문제가 발생했을 때 원인을 찾으려면 애플리케이션 동작을 쉽게 파악할 수 있어야 함

## 보안 서비스 개발

* 4가지 보안 요소
* 인증 : 접근하는 주체의 신원을 확인(일반적으로 ID/패스워드, 애플리케이션 API 키/시크릿 의 자격증명으로 확인)
* 인가 : 주체가 어떤 데이터에 어떤 작업을 요청하여 수행할 권한이 있는지 없는지 확인(역할기반 보안, ACL 을 사용)
* 감사 : 보안 이슈 탐지
* 보안 IPC : 다른 프로세스간에 안전하게 데이터를 주고받을 수 있도록 하는 기술

### VPN과 보안 IPC의 차이점

| 항목 | VPN | 보안 IPC |
|------|------|------|
| **목적** | 네트워크 트래픽을 암호화하여 원격지에서 안전하게 접속 | 같은 시스템 내 또는 네트워크 상에서 프로세스 간 안전한 데이터 교환 |
| **사용 방식** | 인터넷을 통해 원격 네트워크에 안전하게 접속 | 프로세스 간 데이터 전송을 위한 보안 메커니즘 |
| **보안 요소** | 암호화(TLS/IPSec), 인증(계정/키), 터널링 | 인증(프로세스 식별), 접근 제어(ACL), 암호화(전송 보안) |
| **예시** | OpenVPN, WireGuard, IPsec VPN | 보안 메시지 큐, 보안 소켓(TLS/SSL), 보안 공유 메모리 |

### 기존 모놀리식 애플리케이션의 보안

* 보안 아키텍처의 핵신은 세션
* 세션에 주체의 ID와 역할을 보관
* 보통 JSESSIONID라는 http 쿠키에 세션 토큰을 넣어서 요청
* 보안 컨텍스트 정보를 스레드 로컬 변수에 담아, 요청 핸들러가 사용자의 신원/역할 등 모든 저보를 획득할 수 있음
* 인-메모리 세션의 한 가지 단점은 특정 세션의 요청을 모두 동일한 애플리케이션 인스턴스로 라우팅하는 것 -> 부하 분산을 어렵게 함
* 서버쪽 세션을 제거하고 매 요청마다 api 키/시크릿 등 자격증명을 제공하는 클라이언트를 사용하여 서버쪽 세션을 유지안할 수도 있음

### 마이크로서비스 아키텍처에서의 보안 구현

* 모놀리식 애플리케이션의 설계를 그대로 사용할 수가 없음
* **인-메모리 보안 컨텍스트** : 서비스는 메모리를 공유할 수 없기 때문에 스레드 로컬 등 인-메모리 보안을 사용할 수가 없음
* **중앙화 세션** : 인-메모리 보안 컨텍스트가 의미가 없으니 인-메모리 세션도 마찬가지, 이론상 여러 서비스가 DB 및 redis 와 같은 세션 저장소 세션에 접근가능하지만 마이크로서비스 아키텍처에서는 다른 방법이 필요함

#### API 게이트웨이에서 인증 처리

* 다양한 인증 메커니즘을 가지고 있는 클라이언트를 서비스마다 대응하는건 쉬운게 아님
* 요청을 서비스에 보내기 전 API게이트웨이가 요청을 인증하는것이 좋음
* 인증 로직을 중앙화 하면 문제가 생겨도 쉽게 수정가능
* 인증에 필요한 복잡한 코드도 서비스에서 숨길 수 있음
* 자격증명을 포함시켜 요청을 전송하거나(API 클라이언트 방식), 보안 토큰을 게이트웨이로부터 전달 받아 request에 토큰을 함께 보낼 수(로그인 기반 클라이언트) 있음

#### 인가처리

* api 게이트웨이에 인가처리까지 넣게 된다면 서비스가 단단히 결합되는 경우가 발생
* 인가 로직은 서비스에 구현하는게 좋음 (책에서는)

#### JWT로 사용자 신원/역할 전달

* jwt 형식의 토큰에 사용자의 정보를 담아 서비스에 전달하는게 좋음
* 문제는 jwt 토큰은 위변조는 쉽지 않지만, 탈취를 통한 사용은 막기가 힘듬
* 만료 기간을 짧게 설정하는게 좋음

#### OAuth 2.0 응용

* 자격증명, 역할 등 사용자 정보를 db로 관리하는 사용자 서비스를 구현?
* OAuth 2.0 표준이 제대로 구현된 기존 서비스나 프레임워크를 가져다 쓰는것이 쉬움
* 핵심 개념
  * **인증서버** : 사용자 인증 및 액세스/리프레시 토큰 획든 API를 제공
  * **액세스 토큰** : 리소스 서브 접근을 허가하는 토큰, 토큰은 주로 JWT를 사용
  * **리프레시 토큰** : 클라잉너트가 새 액세스 토큰을 얻기 위해 필요한 토큰
  * **리소스 서버** : 액세스 토큰으로 접근을 허가하는 서비스, msa에서는 서비스가 곧 리소스 서버
  * **클라이언트** : 리소스 서버에 접근하려는 클라이언트, api게이트웨이가 바로 클라이언트


#### API 클라이언트 인증 방식

| 구분 | 일반적인 OAuth 2.0 방식 | API 게이트웨이를 활용한 방식 |
|------|------------------|-----------------|
| **토큰 전달** | API 클라이언트가 직접 액세스 토큰을 받음 | API Gateway가 토큰을 받아 내부적으로 관리 |
| **API 요청 방식** | API 클라이언트가 `Authorization: Bearer AccessToken`을 포함하여 요청 | API 클라이언트는 `Authorization: Basic ...`을 사용하고, API Gateway가 대신 토큰을 포함 |
| **클라이언트가 토큰을 다루는가?** | 직접 다룸 | 다루지 않음 (API Gateway가 처리) |
| **보안성** | 클라이언트에서 액세스 토큰을 관리해야 하므로 유출 가능성 존재 | 클라이언트가 토큰을 다루지 않으므로 보안성이 향상됨 |
| **적용 사례** | REST API, 모바일 앱, 분산 시스템 | API Gateway를 통한 중앙 인증 관리 |

## 구성 가능한 서비스 개발 설계

* 여러 외부 서비스(카프카의 네트워크 위치, DB 네트워크 위치, 자격 증명 등등)의 구성 프로퍼티가 필요
* 서비스 실행 환경마다 다름, 하드코딩하는건 배포 관리가 어렵고 보안도 취약
* 런타임에 구성 프로퍼티 값을 서비스에 제공하는 외부화 구성 메커니즘은 구현 방식에 따라 푸시/풀 두가지 모델이 있음

* **푸시 모델** : os 환경변수, 구성 파일등을 통해 배포 인프라에서 서비스로 프로퍼티 값을 전달
* **풀 모델** : 서비스 인스턴스가 구성 서버에 접속해서 프로퍼티 값을 읽어옴

### 푸시 기반의 외부화 구성

* 환경 변수 및 구성 파일로 전달
* 스프링부트에서는 파일 및 여러 방법을 통해 순서 및 우선순위에 대한 유연한 방법을 제공함

### 풀 기반의 외부화 구성

* 서비스 인스턴스가 시동 시 자신의 필요한 값을 구성 전용 서버에 접속하여 읽는 방식
* 예를 들면 현재 시크릿 매니저 방식이 여기에 해당함

## 관측 가능한 서비스 설계

* 서비스 가동중 관측이 필요한 여러 관점들이 있음
* **헬스 체크** : 서비스 헬스를 반환하는 끝점을 표출
* **로그 수집** : 서비스 활동을 로깅, 검색/경고 기능이 구현된 중앙 로그 서버에 로그를 출력
* **분산 추적** : 외부 요청에 ID를 붙여 서비스 사이를 드나드는 과정을 추적
* **에외 추적** : 서비스에서 오류가 발생할 때 이를 자동으로 기록하고, 개발자가 쉽게 확인하고 해결할 수 있도록 돕는 기능
* **애플리케이션 지표** : 필요한 지표를 유지하고 수집한 데이터를 지표 서버에 표출
* **감사 로깅** : 사용자 액션을 로깅

### 헬스 체크 API 패턴

* 서비스 인스턴스가 실행 중이지만 초기화 과정이 끝나지 않아 요청을 처리할 준비가 안된 경우가 있음
* 서비스가 실행 중이지만 db 연결 부족등의 이유로 기능적으로 실패할 경우가 있음
* 헬스 체크를 통해 인프라는 인스턴스를 종료하고 새로운 인스턴스를 생성해야 함

#### 헬스 체크 끝점 구현

* 서비스가 외부 인프라에 정상적으로 연결되는지 확인, 가짜 트랜잭션을 호출해서 철저하게 체크도 가능

#### 헬스 체크 끝점 호출

* 배포 인프라가 헬스 체크 끝점을 호출하도록 설정할 필요가 있음
* 주기적으로 호출 필요

### 로그 수집 패턴

* 서비스 인스턴스가 남긴 로그를 로그 수집 파이프 라인을 통해 중앙 로깅 서버로 보냄
* 로깅 서버에서는 록 데이터를 조회, 검색, 분석할 수 있음
* 알림도 구현 가능

### 분산 추적 패턴

* 요청을 처리할 때마다 서비스 호출 트리 정보를 기록
* 외부 요청은 트래이스와 하나 이상의 스팬으로 구성
* 각 외부 요청마다 ID를 부여하여 추적이 가능 (트래이스 ID + 스팬 ID 조합)
* 표준에 정해진 헤더에 트레이스 ID와 스팬 ID를 추가해서 사용
* 집킨과 같은 분산 추적 서버를사용

### 애플리케이션 지표 패턴

* 지표를 수집하여 운영 환경에서 모니터링과 알람을 보내는 기능은 매우 중요
* 지표에는 인프라 수준에서부터 애프리케이션 수준까지 다양함
* 서비스 개발자는 지표를 수집하도록 설정을 구현해야 하며, 서버에 전달하는 기능은 설정이 필요
* 다양한 프레임워크에서는 서비스 수준의 지표 수집도 가능

### 예외 추적 패턴

* 단순한 로그 서비스에서 예외를 취급할 경우 중복이나 여러 줄의 로그 정보를 표현하는데 힘들 수 있음
* 예외의 중복을 처리하고, 알림을 생성하는 기능이 있는 예외 추적 서비스를 따로 두는 것이 필요

### 감사 로깅 패턴

* 사용자의 액션을 기록하는 것

## 서비스 개발: 마이크로서비스 섀시 패턴

* 위에 나온 여러 기능들을 서비스를 개발할 때마다 반복한다는 것은 힘든 일
* 마이크로서비스 섀시는 횡다노간심사에 처리에 특화된 프레임워크들
* 횡단 관심사를 서비스에 작성할 일이 줄어듬

### 마이크로 서비스 셰시

* 마이크로서비스 섀시 프레임워크는 다양한 관심사를 처리 (외부화 구성, 헬스체크 등등)
* 스프링 환경에서는 스프링 클라우드를 마이크로 서비스 섀시를 활용
* 서비스 개발을 하는 모든 언어/플랫폼 조합마다 마이크로서비스 섀시가 하나씩 필요한 단점은 있음

### 이제는 서비스 메시로

* 마이크로서비스 섀시는 다양한 횡단 관심사를 구현하기 좋은 수단이지만, 사용하는 프로그래밍 언어마다 하나씩 필요하다는 단점이 있음
* 그래서 서비스 외부에 위치한 서비스 메시에 구현이 필요함
* 서비스 메시는 하나의 서비스와 다른 서비스, 그리고 외부 어플리케이션 간의 소통을 조정하는 인프라
* 서비스를 드나드는 네트워크 트래픽은 다양한 관심사가 구현된 서비스 메시를 통과
* 다양한 제품중 이스티오가 있음


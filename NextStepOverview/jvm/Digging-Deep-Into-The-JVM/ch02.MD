# 2. 자바 메모리 영역과 메모리 오버플로
## 2.1. 런타임 데이터 영역
* 자바 가상 머신은 프로그램을 실행하는동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리
* 이 영역은 각각 생성/삭제 시점이 있음
### 2.1.1 프로그램 카운터(PC) 레지스터
* 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기' 라고 생각하면 쉬움
* 바이트코드 인터프린터는 pc의 카운터의 값을 바꿔 다음에 실행한 바이트코드 명령어를 선택하는 식으롣 ㅗㅇ작
* 프로그램의 제어 / 분기 / 순환 / 점프 등을 표현
* 예외 처리, 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어짐
* 멀티 스레딩에서 각 스레드는 고유한 프로그램 카운터를 가짐
* 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장하는데, 이 영역을 스레드 프라이빗 메모리라고 한다.

### 2.2.2 자바 가상 머신 스택
* 자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 라이프 사이클이 동일하다.
* 가상 머신 스텍은 메서드를 실행하는 스레드의 메모리 모델을 설명해 준다.
* 메서드 호출때 마다 스택 프레임을 만들어, 스택 프레임을 가상 머신 스택에 push하고 메서드가 끝나면 pop하는 일을 반복한다.
* 보통 자바 메모리에서 스택 이라고 하면 자바 가상 머신 스택을 가르키는데, 특히 지역 변수 테이블을 가르킬 때가 많다.
* 지역 변수 테이블에는 컴파일타임에 알 수 있는 다양한 기본 데이터 타임, 객체 참조, 반환 주소 타입을 저장한다.
* 지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.
* 일반적으로 슬롯 하나는 32비트
* 지역 변수 테이블을 구성하는데 필요한 데이터 공간은 컴파일 과정에서 할당
* 이 공간의 크기는 슬롯 개수임, 용량이 아님
* 자바 가신 머신 명세에서 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이 보다 크면 StackOverflowError
* 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError

### 2.2.3 네이티브 메서드 스택
* 네이티브 메서드 스택은 가상 머신 스택과 비슷한 역할을 함
* 차이점은 가상머신 스택은 자마 메서드(바이트 코드)를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.


```
네이티브 메서드란?

네이티브 메서드는 자바가 아닌 다른 언어(주로 C 또는 C++)로 구현된 메서드입니다.

이 메서드는 JVM이 아닌 운영 체제(Native Code)에서 직접 실행됩니다.

네이티브 메서드는 JNI(Java Native Interface)를 통해 호출됩니다.
```

### 2.2.4 자바 힙
* 자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
* 모든 스레드가 공유 / 가상 머신이 구동될 때 만들어짐
* 객체 인스턴스를 저장하는것이 목표
* 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역, gc 힙이라고도 불림
* ```자바 가상 머신의 힙 메모모리는 신세대, 구세대, 영구 세대, 에덴, 생존자 공간 등으로 나뉜다``` 라고 설명하고 있는데, 이는 G1 컬렉터 이후 주류가 되고 있기 때문이지 앞으로 변경될 가능성도 충분하다.
* 가상 머신 명세에 따르면 힙은 물리적으로 떨어진 메모리에 위치해도 상관은 없으나 논리적으로는 연속디ㅗ어야 함
* 크기를 확장할 수도 있는데(-Xmx & -Xms), 새로운 인스턴를 하당해 줄 힙 공간이 부족하면 OutOfMemory 를 던진다.

### 2.2.5 메서드 영역
* 모든 스레드가 공유
* 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고, JIT 컴파일러가 컴파일한 코드 캐시등을 저장
* 영구 세대에 구현했는데, 영구 세대의 문제 (고정 크기, 클래스 언로드, 성능문제 등등)때문에 네이티브 메모리로 옮겨갔음

|개념|역할|메모리 위치|
|------|---|---|
|메서드 영역|JVM 명세에서 정의된 논리적 영역으로, 클래스 메타데이터를 저장	|물리적 구현에 따라 다름 (PermGen 또는 Metaspace)
|
|PermGen|자바 7 이하에서 메서드 영역을 구현하기 위해 JVM 힙 내에서 사용	|JVM 힙 내부
|
|Metaspace|자바 8부터 메서드 영역을 구현하기 위해 네이티브 메모리에서 사용	|JVM 힙 외부 (네이티브 메모리)
|

* 메서드 영역에서드 가비지 컬렉션이 일어나는데 가비지 컬렉션에 영향을 크게 받지 않음
* 회수할 데이터가 거의 대부분 상수 풀과 타입이라 회수 효과가 적음
* 여기서도 메서드 영역이 꽉 차서 필요한 만큼 메모리를 할당할 수 없다면 OOM이 발생한다.

### 2.2.6 런타임 상수 풀
* 메서드 영역의 일부
* 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 다양한 리터럴과 심벌 참조가 저장.
* 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장
* 클래스 파일 상수 풀과 다르게 크기가 동적임
* 런타임에도 메서드 영역의 상수 풀에 새로운 상수가 추가될 수 있다.
* 메서드 영역을 넘어설 수 없기 때문에 상수 풀 공간이 부족하면 OOM이 발생

### 2.2.7 다이렉트 메모리
* 다이렉트 메모리는 가상 머신 런타임에 속하지는 않으면, 자바 가상 머신 명세에 정의된 영역은 아님
다만 자주 쓰이고 OOM 원이이 된 수 있음
* NIO 기반에 I/O에서는 힙이 아닌 메모리에 직접 할당할 수 있게 됨
* 힙 크기 제약과는 무관하지만, 역시 실제 메모리에 직접 할당하기 때문에 메모리라는것은 변하지 않는 사실임
* 물리 메모리 용량과 프로세서가 다를 수 있는 주소 공간을 넘을 수 없다.
* 이때 사용되는 메모리 영역의 합이 물리 메모리 한계를 넘어서면 OOM이 발생



## 2.3 핫스팟 가상 머신에서의 객체 들여다보기
* 자바 힙에서의 객체 생성, 할당, 레이아웃, 접근 방법 등 전체 과정은?

### 2.3.1 객체 생성
* 언어 수준에서는 객체 생성은 보통 new 키워드를 사용하지만 가상 머신 수준에서는 어떤 과정을 거쳐 객체가 생성될까?
* 가상 머신이 new 명령에 해당하는 바이트코드를 만나면 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.
* 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인
* 만약 준비가 되지 않은 클래스라면 로딩
* 로딩 완료 후 개 객체를 담을 메모리를 할당.
* 자바 힙은 공간을 할당하는 여러가지 방법이 있음
* 힙이 완벽히 규칙적이라면 여유 공간에 순차적으로 쌓는 포인터 밀치기 방식 
* 가용 메모리 블록 목록을 관리하고, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당 후 목록을 갱신하는 여유 목록 방식
* 멀티 쓰레딩 환경에서는 메모리 할당시 여러 쓰레드가 경합이나 할당 과정중에 문제를 발생 시킬 수 있음 / 두가지 해법이 있음
* 메모리 할당을 동기화 하는 방법. 비교 및 교환(CAS)과 실패 시 재시도 방식을 통해 원자적으로 실행 
* 각 스레드 마다 다른 힙의 공간을 할당받아 사용하는 스레드 로컬 할당 버퍼(TALB)
* TLAB방식에서 각 스레드마다 메모리 할당이 끝나면 가상 머신은 할당받은 공간을 0으로 초기화 한다.
* 0으로 초기화 해두었기 때문에 객체의 인스턴스를 초기화 하지 않고 사용해도 기본값(0, false 등등) 을 담고 있는 것이다.
* 다음 단계로 각 객체에 필요한 설정을 해줌
* 어느 클래스의 인스턴스인가?, 클래스의 메타 정보는 어떻게 찾는가?, 객체의 해시 코든느 무엇인가?, GC 세대 나이는 얼마인가? 등등
* 프로그램 관점에서는 위 과정이 끝났다면, 생성자(클래스의 ```<init>()``` 메서드)가 실행되지 않았고, 모든 필드는 기본값이 0인 상태다.
* 일반적으로 new 명령어에 이어서 ```<init>()``` 메서드까지 실행 되어야 진짜 객체가 완성된다.
* new 자바 코드는 바이트 코드로 적혀질때 new와 invokespecial 바이트 코드로 나뉜다. new는 자바 가상 머신 관점에서 객체 생성(메모리 할당)을 담당하고, invokespecial 코드는 프로그램 관점에서 객체 생성(생성자 실행)을 담당한다.

### 2.3.2 객체의 메모리 레이아웃
* 핫스팟 가상머신은 객체를 세 부분으로 나눠 힙에 저장한다.
* 객체 헤더, 인스턴스 데이터, 길이 맞추기용 정렬 패딩

#### 객체 헤더
* 마크 워드 / 클래스 워드 두 유형의 정보를 담음 
* 마크 워드는 객체 자체의 런타임 데이터이다. 해시코드, GC 세대, 락 상태 플래그, 스레드가 점유하는 락 등등
* 클래스 워드는 객체 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장
* 자바 가상 머신은 이 포인터를 통해 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.
* 자바 배열의 경우 배열 길이도 객체 헤더에 저장한다. 위치는 클래스 워드 다음이다.

#### 인스턴스 데이터
* 객체가 실제로 담고 있는 정보 (필드 관련 내용, 부모 클래스 유무, 부모 ㅋ르래스에서 정의한 모든 필드 등)
* 정보의 젖아 순서는 전략 매개 변수(-XX;FieldsAllocationStyple)와 소스 코드에서 필드를 정의한 순서에 따라 달라짐
* 기본적으로 long/double, int, short/char, byte/boolean, 일반 객체 포인터 순으로 할당
* 필드 길이가 같다면 부모 클래스에서 정의된 필드가 자식 클래스 보다 앞에 배치
* +XX:CompactFields 매개 변수를 true로 설정하면 하위 클래스 필드 중 길이가 짧은 것들은 상위 클래스의 변수 사이사이에 끼워 넣어져서 공간이 절약됨

#### 정렬 패딩
* 마지막 세 번째 부분
* 큰 의미는 없음
* 객체의 시작 주소는 8바이트의 배수여야 해서 정렬 패딩으로 채움

### 2.3.3 객체에 접근하기
* 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에 접근해 이를 조작한다.
* 가상머신에서는 주로 핸들이나 다이렉트 포인터를 사용해 객체 접근을 구현한다.
* 핸들 방식에서는 자바 힙에 핸들 저장용 풀이 별도로 존재
* 스택에 있는 참조에는 핸들 주소가 저장 / 핸들에는 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보가 담김
* 가장 큰 장점은 '안정적인' 핸들의 주소가 저장ㄷ욈
* 다이렉트 포인터 방식에서는 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 방법도 제공해야 한다.
* 스택 참조에는 객체 실제 주소가 저장된다.
* 가장 큰 장점은 속도

## 2.4. OOM 발생시켜보기

### 2.4.1 자바 힙 오버플로우
* 자바 힙은 객체 인스턴스를 저장하는 공간
* 객체에 접근할 경로가 살아 있다면 언젠가는 힙의 최대 용량을 넘어설 것
* 힙 크기 : 20MB
* VM arg : -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
* 테스트 코드 : [HeapOOM](../Digging-Deep-Into-The-JVM/jvm/src/ch02/HeapOOM.java)
* 결과
```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid8119.hprof ...
Heap dump file created [30324569 bytes in 0.038 secs]
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space <- 자바 힙에서 예외 발생
	at java.base/java.util.Arrays.copyOf(Arrays.java:3512)
	at java.base/java.util.Arrays.copyOf(Arrays.java:3481)
	at java.base/java.util.ArrayList.grow(ArrayList.java:237)
	at java.base/java.util.ArrayList.grow(ArrayList.java:244)
	at java.base/java.util.ArrayList.add(ArrayList.java:454)
	at java.base/java.util.ArrayList.add(ArrayList.java:467)
	at ch02.HeapOOM.main(HeapOOM.java:13)

 ```
* 실제로 자바 애플리케이션에서 OOM 이 가장 많이 발생하는 영역이 자바 힙
* 자바 힙에서 오버플로우가 발생하면 메시지 옆에 ```Java heap space``` 라고 출력
* 일반적인 해결 방법은 메모리 이미지 분석 도구로 힙 덤프 스냅샷을 분석해 보는 것
* 첫번째로 ```오버플로우를 일으킨 객체가 꼭 필요한 객체인가```를 확인 해야 함
* GC 루트까지 참조 사슬을 살펴봐야 함
* 누수 된 객체의 타입 정보와 GC 루트까지의 참조 사슬 정보를 보면 대부분의 경우 해당 객체가 만들어진 위치를 더 정확히 알 수 있다.

### 2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로
* 핫스팟 가상 머신은 가상 머신 스태고가 네이티브 메서드 스택을 구분하지 않는다.
* 따라서 네이티브 메서드 스택의 크기를 설정하는  -Xoss 매개 변수를 설정하더라도 아무런 효과가 없다.
* 스택 크기는 오직 -Xss 매개 변수로 설정 할 수 있다.
* 자바 가상 머신 명세에 따르면 가상 머신 스택과 네이티브 메서드 스택에서는 다음 두 경우에 예외가 발생한다.
    1. 스레드가 요구하는 스택 깊이가 가상 머신이 허용하는 최대 깊이보다 크면 SOF 를 던짐
	2. 가상 머신이 스택 메모리를 동적으로 확장하는 기능을 지원하나, 가용 메모리가 부족해 스택을 더 확장할 수 없다면 OOM을 발생
* 핫스팟 가상 머신은 확장을 지원하지 않기 때문에 스레드를 생성할 때 메모리가 부족하여 OOM가 나는 경우를 제외하고는 스레드 실행 중에 가상 머신 스택이 넘치는 일은 없다.
* 즉 스택 용량이 부족하여 새로운 스택 프레임을 담을 수 없을 때만 SOF 가 발생
* 단일 스레드로 한정한 상태에서 아래 두 동작을 수행해 OOM을 던지는 SOF를 던지는지 확인해보자
    1. -Xss 매개 변수로 스택 메모리 용량을 줄임
	2. 지역 번수를 많이 선언해서 메서드 프레임의 지역 변수 크기를 키움

#### 첫번째 상황에서는 SOF가 발생했다.
* 예외 발생 시 출력된 스택 깊이는 의도대로 축소되어 있다.
* VM arg : -Xss208k
* 테스트 코드 : [JavaVMStackSOF_1](../Digging-Deep-Into-The-JVM/jvm/src/ch02/JavaVMStackSOF_1.java)
* 결과
```
Exception in thread "main" java.lang.StackOverflowError
    ...
	at ch02.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:8)
	at ch02.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:8)
	at ch02.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:8)
	at ch02.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:8)
	at ch02.JavaVMStackSOF_1.main(JavaVMStackSOF_1.java:15)
stack length: 830
```

#### 두번째 상황에서도 SOF가 발생했다.
* 지역 메모리 테이블 공간을 더 많이 점유하기 위해 변수를 메우 많이 정의

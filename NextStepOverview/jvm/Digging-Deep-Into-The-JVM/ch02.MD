# 2. 자바 메모리 영역과 메모리 오버플로
## 2.1. 런타임 데이터 영역
* 자바 가상 머신은 프로그램을 실행하는동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리
* 이 영역은 각각 생성/삭제 시점이 있음
### 2.1.1 프로그램 카운터(PC) 레지스터
* 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기' 라고 생각하면 쉬움
* 바이트코드 인터프린터는 pc의 카운터의 값을 바꿔 다음에 실행한 바이트코드 명령어를 선택하는 식으롣 ㅗㅇ작
* 프로그램의 제어 / 분기 / 순환 / 점프 등을 표현
* 예외 처리, 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어짐
* 멀티 스레딩에서 각 스레드는 고유한 프로그램 카운터를 가짐
* 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장하는데, 이 영역을 스레드 프라이빗 메모리라고 한다.

### 2.2.2 자바 가상 머신 스택
* 자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 라이프 사이클이 동일하다.
* 가상 머신 스텍은 메서드를 실행하는 스레드의 메모리 모델을 설명해 준다.
* 메서드 호출때 마다 스택 프레임을 만들어, 스택 프레임을 가상 머신 스택에 push하고 메서드가 끝나면 pop하는 일을 반복한다.
* 보통 자바 메모리에서 스택 이라고 하면 자바 가상 머신 스택을 가르키는데, 특히 지역 변수 테이블을 가르킬 때가 많다.
* 지역 변수 테이블에는 컴파일타임에 알 수 있는 다양한 기본 데이터 타임, 객체 참조, 반환 주소 타입을 저장한다.
* 지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.
* 일반적으로 슬롯 하나는 32비트
* 지역 변수 테이블을 구성하는데 필요한 데이터 공간은 컴파일 과정에서 할당
* 이 공간의 크기는 슬롯 개수임, 용량이 아님
* 자바 가신 머신 명세에서 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이 보다 크면 StackOverflowError
* 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError

### 2.2.3 네이티브 메서드 스택
* 네이티브 메서드 스택은 가상 머신 스택과 비슷한 역할을 함
* 차이점은 가상머신 스택은 자마 메서드(바이트 코드)를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.


```
네이티브 메서드란?

네이티브 메서드는 자바가 아닌 다른 언어(주로 C 또는 C++)로 구현된 메서드입니다.

이 메서드는 JVM이 아닌 운영 체제(Native Code)에서 직접 실행됩니다.

네이티브 메서드는 JNI(Java Native Interface)를 통해 호출됩니다.
```

### 2.2.4 자바 힙
* 자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
* 모든 스레드가 공유 / 가상 머신이 구동될 때 만들어짐
* 객체 인스턴스를 저장하는것이 목표
* 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역, gc 힙이라고도 불림
* ```자바 가상 머신의 힙 메모모리는 신세대, 구세대, 영구 세대, 에덴, 생존자 공간 등으로 나뉜다``` 라고 설명하고 있는데, 이는 G1 컬렉터 이후 주류가 되고 있기 때문이지 앞으로 변경될 가능성도 충분하다.
* 가상 머신 명세에 따르면 힙은 물리적으로 떨어진 메모리에 위치해도 상관은 없으나 논리적으로는 연속디ㅗ어야 함
* 크기를 확장할 수도 있는데(-Xmx & -Xms), 새로운 인스턴를 하당해 줄 힙 공간이 부족하면 OutOfMemory 를 던진다.

### 2.2.5 메서드 영역
* 모든 스레드가 공유
* 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고, JIT 컴파일러가 컴파일한 코드 캐시등을 저장
* 영구 세대에 구현했는데, 영구 세대의 문제 (고정 크기, 클래스 언로드, 성능문제 등등)때문에 네이티브 메모리로 옮겨갔음

|개념|역할|메모리 위치|
|------|---|---|
|메서드 영역|JVM 명세에서 정의된 논리적 영역으로, 클래스 메타데이터를 저장	|물리적 구현에 따라 다름 (PermGen 또는 Metaspace)
|
|PermGen|자바 7 이하에서 메서드 영역을 구현하기 위해 JVM 힙 내에서 사용	|JVM 힙 내부
|
|Metaspace|자바 8부터 메서드 영역을 구현하기 위해 네이티브 메모리에서 사용	|JVM 힙 외부 (네이티브 메모리)
|

* 메서드 영역에서드 가비지 컬렉션이 일어나는데 가비지 컬렉션에 영향을 크게 받지 않음
* 회수할 데이터가 거의 대부분 상수 풀과 타입이라 회수 효과가 적음
* 여기서도 메서드 영역이 꽉 차서 필요한 만큼 메모리를 할당할 수 없다면 OOM이 발생한다.

### 2.2.6 런타임 상수 풀
* 메서드 영역의 일부
* 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 다양한 리터럴과 심벌 참조가 저장.
* 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장
* 클래스 파일 상수 풀과 다르게 크기가 동적임
* 런타임에도 메서드 영역의 상수 풀에 새로운 상수가 추가될 수 있다.
* 메서드 영역을 넘어설 수 없기 때문에 상수 풀 공간이 부족하면 OOM이 발생

### 2.2.7 다이렉트 메모리
* 다이렉트 메모리는 가상 머신 런타임에 속하지는 않으면, 자바 가상 머신 명세에 정의된 영역은 아님
다만 자주 쓰이고 OOM 원이이 된 수 있음
* NIO 기반에 I/O에서는 힙이 아닌 메모리에 직접 할당할 수 있게 됨
* 힙 크기 제약과는 무관하지만, 역시 실제 메모리에 직접 할당하기 때문에 메모리라는것은 변하지 않는 사실임
* 물리 메모리 용량과 프로세서가 다를 수 있는 주소 공간을 넘을 수 없다.
* 이때 사용되는 메모리 영역의 합이 물리 메모리 한계를 넘어서면 OOM이 발생

# 2. 자바 메모리 영역과 메모리 오버플로
## 2.1. 런타임 데이터 영역
* 자바 가상 머신은 프로그램을 실행하는동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리
* 이 영역은 각각 생성/삭제 시점이 있음
### 2.1.1 프로그램 카운터(PC) 레지스터
* 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기' 라고 생각하면 쉬움
* 바이트코드 인터프린터는 pc의 카운터의 값을 바꿔 다음에 실행한 바이트코드 명령어를 선택하는 식으롣 ㅗㅇ작
* 프로그램의 제어 / 분기 / 순환 / 점프 등을 표현
* 예외 처리, 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어짐
* 멀티 스레딩에서 각 스레드는 고유한 프로그램 카운터를 가짐
* 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장하는데, 이 영역을 스레드 프라이빗 메모리라고 한다.

### 2.2.2 자바 가상 머신 스택
* 자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 라이프 사이클이 동일하다.
* 가상 머신 스텍은 메서드를 실행하는 스레드의 메모리 모델을 설명해 준다.
* 메서드 호출때 마다 스택 프레임을 만들어, 스택 프레임을 가상 머신 스택에 push하고 메서드가 끝나면 pop하는 일을 반복한다.
* 보통 자바 메모리에서 스택 이라고 하면 자바 가상 머신 스택을 가르키는데, 특히 지역 변수 테이블을 가르킬 때가 많다.
* 지역 변수 테이블에는 컴파일타임에 알 수 있는 다양한 기본 데이터 타임, 객체 참조, 반환 주소 타입을 저장한다.
* 지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.
* 일반적으로 슬롯 하나는 32비트
* 지역 변수 테이블을 구성하는데 필요한 데이터 공간은 컴파일 과정에서 할당
* 이 공간의 크기는 슬롯 개수임, 용량이 아님
* 자바 가신 머신 명세에서 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이 보다 크면 StackOverflowError
* 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError

### 2.2.3 네이티브 메서드 스택
* 네이티브 메서드 스택은 가상 머신 스택과 비슷한 역할을 함
* 차이점은 가상머신 스택은 자마 메서드(바이트 코드)를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.


```
네이티브 메서드란?

네이티브 메서드는 자바가 아닌 다른 언어(주로 C 또는 C++)로 구현된 메서드입니다.

이 메서드는 JVM이 아닌 운영 체제(Native Code)에서 직접 실행됩니다.

네이티브 메서드는 JNI(Java Native Interface)를 통해 호출됩니다.
```

### 2.2.4 자바 힙
* 자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
* 모든 스레드가 공유 / 가상 머신이 구동될 때 만들어짐
* 객체 인스턴스를 저장하는것이 목표
* 자바 힙은 가비지 컬렉터가 관리하는 메모리 영역, gc 힙이라고도 불림
* ```자바 가상 머신의 힙 메모모리는 신세대, 구세대, 영구 세대, 에덴, 생존자 공간 등으로 나뉜다``` 라고 설명하고 있는데, 이는 G1 컬렉터 이후 주류가 되고 있기 때문이지 앞으로 변경될 가능성도 충분하다.
* 가상 머신 명세에 따르면 힙은 물리적으로 떨어진 메모리에 위치해도 상관은 없으나 논리적으로는 연속디ㅗ어야 함
* 크기를 확장할 수도 있는데(-Xmx & -Xms), 새로운 인스턴를 하당해 줄 힙 공간이 부족하면 OutOfMemory 를 던진다.

### 2.2.5 메서드 영역
* 모든 스레드가 공유
* 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고, JIT 컴파일러가 컴파일한 코드 캐시등을 저장
* 영구 세대에 구현했는데, 영구 세대의 문제 (고정 크기, 클래스 언로드, 성능문제 등등)때문에 네이티브 메모리로 옮겨갔음

|개념|역할|메모리 위치|
|------|---|---|
|메서드 영역|JVM 명세에서 정의된 논리적 영역으로, 클래스 메타데이터를 저장	|물리적 구현에 따라 다름 (PermGen 또는 Metaspace)
|
|PermGen|자바 7 이하에서 메서드 영역을 구현하기 위해 JVM 힙 내에서 사용	|JVM 힙 내부
|
|Metaspace|자바 8부터 메서드 영역을 구현하기 위해 네이티브 메모리에서 사용	|JVM 힙 외부 (네이티브 메모리)
|

* 메서드 영역에서드 가비지 컬렉션이 일어나는데 가비지 컬렉션에 영향을 크게 받지 않음
* 회수할 데이터가 거의 대부분 상수 풀과 타입이라 회수 효과가 적음
* 여기서도 메서드 영역이 꽉 차서 필요한 만큼 메모리를 할당할 수 없다면 OOM이 발생한다.

### 2.2.6 런타임 상수 풀
* 메서드 영역의 일부
* 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 다양한 리터럴과 심벌 참조가 저장.
* 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장
* 클래스 파일 상수 풀과 다르게 크기가 동적임
* 런타임에도 메서드 영역의 상수 풀에 새로운 상수가 추가될 수 있다.
* 메서드 영역을 넘어설 수 없기 때문에 상수 풀 공간이 부족하면 OOM이 발생

### 2.2.7 다이렉트 메모리
* 다이렉트 메모리는 가상 머신 런타임에 속하지는 않으면, 자바 가상 머신 명세에 정의된 영역은 아님
다만 자주 쓰이고 OOM 원이이 된 수 있음
* NIO 기반에 I/O에서는 힙이 아닌 메모리에 직접 할당할 수 있게 됨
* 힙 크기 제약과는 무관하지만, 역시 실제 메모리에 직접 할당하기 때문에 메모리라는것은 변하지 않는 사실임
* 물리 메모리 용량과 프로세서가 다를 수 있는 주소 공간을 넘을 수 없다.
* 이때 사용되는 메모리 영역의 합이 물리 메모리 한계를 넘어서면 OOM이 발생



## 2.3 핫스팟 가상 머신에서의 객체 들여다보기
* 자바 힙에서의 객체 생성, 할당, 레이아웃, 접근 방법 등 전체 과정은?

### 2.3.1 객체 생성
* 언어 수준에서는 객체 생성은 보통 new 키워드를 사용하지만 가상 머신 수준에서는 어떤 과정을 거쳐 객체가 생성될까?
* 가상 머신이 new 명령에 해당하는 바이트코드를 만나면 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.
* 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인
* 만약 준비가 되지 않은 클래스라면 로딩
* 로딩 완료 후 개 객체를 담을 메모리를 할당.
* 자바 힙은 공간을 할당하는 여러가지 방법이 있음
* 힙이 완벽히 규칙적이라면 여유 공간에 순차적으로 쌓는 포인터 밀치기 방식 
* 가용 메모리 블록 목록을 관리하고, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당 후 목록을 갱신하는 여유 목록 방식
* 멀티 쓰레딩 환경에서는 메모리 할당시 여러 쓰레드가 경합이나 할당 과정중에 문제를 발생 시킬 수 있음 / 두가지 해법이 있음
* 메모리 할당을 동기화 하는 방법. 비교 및 교환(CAS)과 실패 시 재시도 방식을 통해 원자적으로 실행 
* 각 스레드 마다 다른 힙의 공간을 할당받아 사용하는 스레드 로컬 할당 버퍼(TALB)
* TLAB방식에서 각 스레드마다 메모리 할당이 끝나면 가상 머신은 할당받은 공간을 0으로 초기화 한다.
* 0으로 초기화 해두었기 때문에 객체의 인스턴스를 초기화 하지 않고 사용해도 기본값(0, false 등등) 을 담고 있는 것이다.
* 다음 단계로 각 객체에 필요한 설정을 해줌
* 어느 클래스의 인스턴스인가?, 클래스의 메타 정보는 어떻게 찾는가?, 객체의 해시 코든느 무엇인가?, GC 세대 나이는 얼마인가? 등등
* 프로그램 관점에서는 위 과정이 끝났다면, 생성자(클래스의 ```<init>()``` 메서드)가 실행되지 않았고, 모든 필드는 기본값이 0인 상태다.
* 일반적으로 new 명령어에 이어서 ```<init>()``` 메서드까지 실행 되어야 진짜 객체가 완성된다.
* new 자바 코드는 바이트 코드로 적혀질때 new와 invokespecial 바이트 코드로 나뉜다. new는 자바 가상 머신 관점에서 객체 생성(메모리 할당)을 담당하고, invokespecial 코드는 프로그램 관점에서 객체 생성(생성자 실행)을 담당한다.